--Анисимов Алексей A3201
--Написать функцию prodIndices:: [Integer] -> [Int],
--которая по списку целых чисео выдает список индексов тех его
--элементов, которые являются произведениями  двухс соседних
--эл-в (если один из соседних элементов отсутствует, то он полагается 
--равным единице).

--Для умножения элементов через 1 нужно к изначальному списку добавить 1
--справа, к вспомогательному 1 слева(и убрать 1 слева и справа соответственно)
--(reverse(1:(reverse (xs)))) (1:list). Затем с помощью
--map формируются пары этих списков, а потом анонимной функцией
--числа внутри пар перемножаются. Получившийся список необходимо сравнить
--с изачальным. И сохранить индексы совпавших элементов.
--За это отвечает checkLists.

main' :: [[Int]] 
main' = [
	prodIndices[1,1,1,1,1],
	prodIndices[1,2,3,4],
	prodIndices[1,-2,6,-3,0,0],
	prodIndices[0,1,0,1,0,0]]
	
prodIndices :: [Integer] -> [Int]
checkLists :: [Integer] -> [Integer] -> Int -> [Int]
prodIndices list@(x:xs) = checkLists ( map (\(x, y) -> x * y)(zip (reverse(1:(reverse (xs)))) (1:list))) list 0
checkLists (x:xs) (y:ys) val | y == x = (val:(checkLists xs ys (val+1)))
						     | otherwise = checkLists xs ys (val+1)
checkLists [] [] _ = []